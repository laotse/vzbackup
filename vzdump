#!/usr/bin/perl -w
#
#    Copyright (C) 2007-2008 Proxmox Server Solutions GmbH
#
#    Copyright: vzdump is under GNU GPL, the GNU General Public License.
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; version 2 dated June, 1991.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the
#    Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
#    MA 02110-1301, USA.
#
#    Author: Dietmar Maurer <dietmar@proxmox.com>,
#            Lars Hanke <lars@lhanke.de>
#

use strict;
use warnings;
use Getopt::Long;
use Fcntl qw( :flock :mode );
use Sys::Syslog;
use File::Path;
use File::Basename;
use File::Spec;
use File::stat;
use IO::File;
use IO::Select;
use IPC::Open3;
use POSIX qw(strftime);
use Storable qw(dclone);

my %OPT;
#$OPT{all};
#$OPT{exclude};
#$OPT{exclude_path};
#$OPT{quiet};
#$OPT{dumpdir};
$OPT{compress} = 0;
#$OPT{restore};
#$OPT{mailto};
#$OPT{stop};
#$OPT{suspend};
#$OPT{snap};
#$OPT{node};
#$OPT{tmpdir};
#$OPT{bwlimit};
#$OPT{lockwait};
#$OPT{stopwait};
#$OPT{snapsize};
#$OPT{stdexcludes};
$OPT{noarch} = 0;
$OPT{sane} = 0;
$OPT{filesys} = 0;
$OPT{lvm} = 0;
#$OPT{plugin};

my $stopmode = '';

my $vzctl = 'vzctl';
my $qmctl = 'qm';
my $rsync = 'rsync';
my $lvcreate = 'lvcreate';
my $lvs = 'lvs';
my $lvremove = 'lvremove';
my $sendmail = 'sendmail';
my $pveca = 'pveca';
my $cpcmd = 'cp';
my $ducmd = 'du';
my $gzip = 'gzip';
my $cstream = 'cstream';

my $vzdir = '/etc/vz';
my $qmdir = '/etc/qemu-server';

my $logdir = '/var/log/vzdump';
my $lockfile = '/var/run/vzdump.lock';

my @script_ext = qw (start stop mount umount);

my $cmdline = join (' ', 'vzdump', @ARGV);

openlog ('vzdump', 'cons,pid', 'daemon');

# by default we set --rsyncable for gzip
$ENV{GZIP} = "--rsyncable" if !$ENV{GZIP};
$ENV{LANG} = "C"; # avoid locale related issues/warnings

my $debugstattxt = {
    err =>  'ERROR:',
    info => 'INFO:',
    warn => 'WARN:',
};

my $plugs;

#######################################
# helper functions
#######################################

my @safe_paths = ();

sub safe_mkpath {
    my $path = shift;
    $path = File::Spec->canonpath($path);
    $path = File::Spec->rel2abs($path);
    my @npaths = mkpath( $path );
    @safe_paths = (@safe_paths, @npaths );
    return @npaths;
}

sub safe_rmtree {
    my $path = shift;
    $path = File::Spec->canonpath($path);
    $path = File::Spec->rel2abs($path);
    foreach my $i (0..$#safe_paths) {
	my $p = $safe_paths[$i];
	if( $path =~ /^$p/ ){
	    rmtree( $path );
	    if( $path eq $p ){
		splice(@safe_paths,$i,1);
		return;
	    }
	}
    }
    debugmsg('warn',"Unsafe directory $path not removed") if( -d $path );

}

sub debugmsg {
    my ($mtype, $msg, $logfd, $syslog) = @_;

    chomp $msg;

    return if !$msg;

    my $pre = $debugstattxt->{$mtype} || $debugstattxt->{'err'};

    my $tstr = strftime ("%b %d %H:%M:%S", localtime);

    syslog ($mtype eq 'info' ? 'info' : 'err', $msg) if $syslog;

    foreach my $line (split (/\n/, $msg)) {
	print "$pre $line\n" if !$OPT{quiet};
	print $logfd "$tstr $pre $line\n" if $logfd;
    }
}

sub run_command {
    my ($logfd, $cmdstr, $input, $timeout) = @_;

    my $reader = IO::File->new();
    my $writer = IO::File->new();
    my $error  = IO::File->new();

    my $orig_pid = $$;

    my $pid;
    eval {
	$pid = open3 ($writer, $reader, $error, ($cmdstr)) || die $!;
    };

    my $err = $@;

    # catch exec errors
    if ($orig_pid != $$) {
	debugmsg ('err', "command '$cmdstr' failed - fork failed", $logfd);
	POSIX::_exit (1);
	kill ('KILL', $$);
    }

    die $err if $err;

    print $writer $input if defined $input;
    close $writer;

    my $select = new IO::Select;
    $select->add ($reader);
    $select->add ($error);

    my ($ostream, $estream, $logout, $logerr) = ('', '', '', '');

    while ($select->count) {
	my @handles = $select->can_read ($timeout);

	if (defined ($timeout) && (scalar (@handles) == 0)) {
	    die "command '$cmdstr' failed: timeout";
	}

	foreach my $h (@handles) {
	    my $buf = '';
	    my $count = sysread ($h, $buf, 4096);
	    if (!defined ($count)) {
		waitpid ($pid, 0);
		die "command '$cmdstr' failed: $!";
	    }
	    $select->remove ($h) if !$count;

	    if ($h eq $reader) {
		$ostream .= $buf;
		$logout .= $buf;
		while ($logout =~ s/^([^\n]*\n)//s) {
		    my $line = $1;
		    debugmsg ('info', $line, $logfd);
		}
	    } elsif ($h eq $error) {
		$estream .= $buf;
		$logerr .= $buf;
		while ($logerr =~  s/^([^\n]*\n)//s) {
		    my $line = $1;
		    debugmsg ('info', $line, $logfd);
		}
	    }
	}
    }

    debugmsg ('info', $logout, $logfd);
    debugmsg ('info', $logerr, $logfd);

    waitpid ($pid, 0);
    my $ec = ($? >> 8);

    return $ostream if $ec == 24 && ($cmdstr =~ m/^$rsync/);

    die "command '$cmdstr' failed with exit code $ec\n" if $ec;

    return $ostream;
}

sub format_size {
    my $size = shift;

    my $kb = $size / 1024;

    if ($kb < 1024) {
	return int ($kb) . "KB";
    }

    my $mb = $size / (1024*1024);

    if ($mb < 1024) {
	return int ($mb) . "MB";
    } else {
	my $gb = $mb / 1024;
	return sprintf ("%.2fGB", $gb);
    }
}

sub format_time {
    my $seconds = shift;

    my $hours = int ($seconds/3600);
    $seconds = $seconds - $hours*3600;
    my $min = int ($seconds/60);
    $seconds = $seconds - $min*60;

    return sprintf ("%02d:%02d:%02d", $hours, $min, $seconds);
}

sub remove_quotes {
    my $str = shift;

    $str =~ s/^\s*\"?//;
    $str =~ s/\"?\s*$//;

    return $str;
}

sub check_bin {
    my ($bin, $msg)  = @_;

    my $v = $$bin;

    my $path = "/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin";

    foreach my $p (split (/:/, $path)) {
	my $fn = "$p/$v";
	if (-x $fn) {
	    $$bin = $fn;
	    return;
	}
    }

    if ($msg) {
	die "unable to find '$v' - $msg\n";
    } else {
	$$bin = undef;
    }
}

sub check_vpsid {
    my $vpsid = shift;

    if ($vpsid !~ m/^\d\d\d+$/) {
	print_usage ("strange VPS ID '${vpsid}'");
	exit (-1);
    }
}

sub getlock {
    my ($maxwait) = @_;

    if (!open (SERVER_FLCK, ">>$lockfile")) {
	debugmsg ('err', "can't open lock on file '$lockfile' - $!", undef, 1);
	exit (-1);
    }


    if (flock (SERVER_FLCK, LOCK_EX|LOCK_NB)) {
	return;
    }

    if (!$maxwait) {
	debugmsg ('err', "can't aquire lock '$lockfile' (wait = 0)", undef, 1);
	exit (-1);
    }

    debugmsg('info', "trying to get global lock - waiting...", undef, 1);

    eval {
	alarm ($maxwait * 60);

	local $SIG{ALRM} = sub { alarm (0); die "got timeout\n"; };

	if (!flock (SERVER_FLCK, LOCK_EX)) {
	    my $err = $!;
	    close (SERVER_FLCK);
	    alarm (0);
	    die "$err\n";
	}
	alarm (0);
    };
    alarm (0);

    my $err = $@;

    if ($err) {
	debugmsg ('err', "can't aquire lock '$lockfile' - $err", undef, 1);
	exit (-1);
    }

    debugmsg('info', "got global lock", undef, 1);
}

sub check_perm {
    my ($file, $perm) = @_;

    my $fb = stat(__FILE__);
    my $sb = stat($file);
    die "File $file has insecure owner"
	unless(($sb->uid == $fb->uid) || ($sb->uid == 0));
    die "File $file has insecure group"
	unless(($sb->gid == $fb->gid) || ($sb->gid == 0));

    my $type = $sb->mode & (S_IFDIR | S_IFREG);
    die "File $file is neither a directory nor a regular file!"
        unless(($type == S_IFDIR) || ($type == S_IFREG));

    my $mode = $sb->mode & 07777;
    if ($type == S_IFDIR){
        die "Directory mode of $file is unsafe!"
            unless (($mode | $perm) == $perm);
    } else {
	die "File mode of $file is unsafe!"
	    unless (($mode | $perm) == $perm);
    }
}


#######################################
# Configuration parsing
#######################################

sub read_vzdump_defaults {

    my $fn = "/etc/vzdump.conf";

    my $res = {
	tmpdir => "/var/tmp",
	bwlimit => 10240,
	size => 1024,
	lockwait => 3*60, # 3 hours
	stopwait => 10, # 10 minutes
	plugpath => File::Spec->rel2abs('.'),
    };

    my $fh = IO::File->new ("<$fn");
    return $res if !$fh;

    my $line;
    while (defined ($line = <$fh>)) {
	next if $line =~ m/^\s*$/;
	next if $line =~ m/^\#/;

	if ($line =~ m/tmpdir:\s*(.*\S)\s*$/) {
	    $res->{tmpdir} = $1;
	} elsif ($line =~ m/dumpdir:\s*(.*\S)\s*$/) {
	    $res->{dumpdir} = $1;
	} elsif ($line =~ m/bwlimit:\s*(\d+)\s*$/) {
	    $res->{bwlimit} = int($1);
	} elsif ($line =~ m/lockwait:\s*(\d+)\s*$/) {
	    $res->{lockwait} = int($1);
	} elsif ($line =~ m/stopwait:\s*(\d+)\s*$/) {
	    $res->{stopwait} = int($1);
	} elsif ($line =~ m/size:\s*(\d+)\s*$/) {
	    $res->{size} = int($1);
	} elsif ($line =~ m/mode:\s*(stop|snapshot|suspend)\s*$/) {
	    $res->{mode} = $1;
	} elsif ($line =~ m/pluginpath:\s*([^\s]+|\".*\"|\'.*\')\s*$/) {
	    $res->{plugpath} = $1;
	    $res->{plugpath} =~ s/^\"(.*)\"$/$1/;
	    $res->{plugpath} =~ s/^\'(.*)\'$/$1/;
	    $res->{plugpath} = File::Spec->canonpath($res->{plugpath});
	    $res->{plugpath} = File::Spec->rel2abs($res->{plugpath});
	    die "Plugin directory $res->{plugpath} does not exist!"
		unless( -d "$res->{plugpath}" );
	} else {
	    debugmsg ('warn', "unable to parse configuration file '$fn' - error at line " . $., undef, 1);
	}

    }
    close ($fh);
    return $res;
}

# read global vz.conf
sub read_global_vz_config {

    local $/;

    my $res = {
	rootdir => '/vz/root',
	privatedir => '/vz/private',
	dumpdir => '/vz/dump',
    };

    my $filename = "$vzdir/vz.conf";

    return $res if ! -f $filename;

    open (TMP, "<$filename");
    my $data = <TMP> || '';
    close (TMP);

    if ($data =~ m/^\s*VE_PRIVATE=(.*)$/m) {
	my $dir = remove_quotes ($1);
	$dir =~ s|/\$VEID$||;
	$res->{privatedir} = $dir;
    }
    if ($data =~ m/^\s*VE_ROOT=(.*)$/m) {
	my $dir = remove_quotes ($1);
	$dir =~ s|/\$VEID$||;
	$res->{rootdir} = $dir;
    }
    if ($data =~ m/^\s*DUMPDIR=(.*)$/m) {
	my $dir = remove_quotes ($1);
	$dir =~ s|/\$VEID$||;
	$res->{dumpdir} = $dir;
    }

    return $res;
}

sub read_vz_list {
    my ($vzconf, $vmlist) = @_;

    my $cfgdir = "$vzdir/conf";

    foreach my $conf (<$cfgdir/*.conf>) {

	next if $conf !~ m|/(\d\d\d+)\.conf$|;

	my $vpsid = $1;
	local $/;

	open (TMP, "<$conf");
	my $data = <TMP>;
	close (TMP);

	$vmlist->{$vpsid}->{type} = "openvz";
	$vmlist->{$vpsid}->{conffile} = $conf;

	if ($data =~ m/^\s*VE_PRIVATE=(.*)$/m) {
	    my $dir = remove_quotes ($1);
	    $dir =~ s/\$VEID/$vpsid/;
	    $vmlist->{$vpsid}->{dir} = $dir;
	} else {
	    $vmlist->{$vpsid}->{dir} = "$vzconf->{privatedir}/$vpsid";
	}

	if ($data =~ m/^\s*HOSTNAME=(.*)/m) {
	    $vmlist->{$vpsid}->{hostname} = remove_quotes ($1);
	} else {
	    $vmlist->{$vpsid}->{hostname} = "CT $vpsid";
	}
    }
}

sub read_qm_list {
    my ($vmlist) = @_;

    foreach my $conf (</etc/qemu-server/*.conf>) {
	next if $conf !~ m|/(\d\d\d+)\.conf$|;

	my $vpsid = $1;
	if (defined ($vmlist->{$vpsid})) {
	    debugmsg ('info', "found duplicate VPSID $vpsid");
	    next;
	}

	local $/;

	open (TMP, "<$conf");
	my $data = <TMP>;
	close (TMP);

	my $private = "/var/lib/vz/images/$vpsid";

	$vmlist->{$vpsid}->{type} = "qemu";
	$vmlist->{$vpsid}->{conffile} = $conf;
	$vmlist->{$vpsid}->{dir} = $private;

	if ($data =~ m/^\s*name:\s*(.*)\s*/im) {
	    $vmlist->{$vpsid}->{hostname} = $1;
	} else {
	    $vmlist->{$vpsid}->{hostname} = "VM $vpsid";
	}
    }
}

#######################################
# LVM utilities
#######################################

sub get_lvm_mapping {

    my $devmapper;

    my $cmd = "$lvs --units m --separator ':' --noheadings -o vg_name,lv_name,lv_size";
    if (my $fd = IO::File->new ("$cmd 2>/dev/null|")) {
	while (my $line = <$fd>) {
	    if ($line =~ m|^\s*(\S+):(\S+):(\d+\.\d+)M$|) {
		my $vg = $1;
		my $lv = $2;
		$devmapper->{"/dev/$vg/$lv"} = [$vg, $lv];
		$devmapper->{"/dev/mapper/$vg-$lv"} = [$vg, $lv];
	    }
	}
	close ($fd);
    }

    return $devmapper;
}

sub get_lvm_device {
    my ($dir, $mapping) = @_;

    my $fd = IO::File->new ("df -P -T '$dir' 2>/dev/null|");
    <$fd>; #skip first line
    my $out = <$fd>;
    close ($fd);

    return undef if !$out;

    my @res = split (/\s+/, $out);

    my $dev = $res[0];
    my $fstype = $res[1];
    my $mp = $res[6];

    my ($vg, $lv);

    ($vg, $lv) = @{$mapping->{$dev}} if defined $mapping->{$dev};

    return wantarray ? ($dev, $mp, $vg, $lv, $fstype) : $dev;
}

sub lvm_cleanup {
    my ($logfd, $snapdev) = @_;

    eval { run_command ($logfd, "umount /mnt/vzsnap"); };
    debugmsg ('info', $@, $logfd) if $@;

    eval { run_command ($logfd, "$lvremove -f $snapdev"); };
    debugmsg ('info', $@, $logfd) if $@;
}

sub determine_lvm {
    my ($bckpar,$logfd) = @_;

    my $lvmmap = get_lvm_mapping();
    my ($srcdev, $lvmpath, $lvmvg, $lvmlv, $fstype) =
	get_lvm_device ($bckpar->{dir}, $lvmmap);

    my $targetdev = get_lvm_device ($bckpar->{dumpdir}, $lvmmap);

    if (!$lvmvg) {
	$bckpar->{stopmode} = 'suspend';
	debugmsg ('err', "unable to detect lvm volume group, " .
		  "using 'suspend' mode", $logfd);
    } elsif ($bckpar->{dir} !~ m|/?$lvmpath/?|) {
	$bckpar->{stopmode} = 'suspend';
	debugmsg ('err', "wrong lvm mount point '$lvmpath', " .
		  "using 'suspend' mode", $logfd);
    } elsif ($targetdev eq $srcdev) {
	$bckpar->{stopmode} = 'suspend';
	debugmsg ('err', "unable to dump into snapshot " .
		  "(use option --dumpdir), using 'suspend' mode", $logfd);
    } else {
	$bckpar->{snapdev} = "/dev/$lvmvg/vzsnap";
	$bckpar->{srcdev}  = $srcdev;
	$bckpar->{lvmvg}   = $lvmvg;
	$bckpar->{lvmlv}   = $lvmlv;
	$bckpar->{fstype}  = $fstype;
	$bckpar->{lvmpath} = $lvmpath;
	return 1;
    }
    return 0;
}

sub lvmsnapshot {
    my ($bckpar, $logfd) = @_;

    debugmsg ('error', "Attempting lvmsnapshot() without successful determie_lvm()", $logfd) if( ! exists $bckpar->{snapdev});

    safe_mkpath "/mnt/vzsnap"; # create mount point for lvm snapshot

    if (-b $bckpar->{snapdev}) {
	debugmsg ('info', "trying to remove stale snapshot '$bckpar->{snapdev}'", $logfd);
	lvm_cleanup ($logfd, $bckpar->{snapdev});
    }

    debugmsg ('info', "creating lvm snapshot of $bckpar->{srcdev} ('$bckpar->{snapdev}')", $logfd);
    run_command ($logfd, "$lvcreate --size ${OPT{snapsize}}M --snapshot" .
			 " --name vzsnap /dev/$bckpar->{lvmvg}/$bckpar->{lvmlv}");

}

sub mount_snapshot {
    my ($bckpar, $logfd) = @_;

    debugmsg ('info', "mounting lvm snapshot", $logfd);

    my $mopts = "";
    $mopts = "-o nouuid" if $bckpar->{fstype} eq 'xfs';

    eval {
	run_command ($logfd, "mount -t $bckpar->{fstype} $mopts $bckpar->{snapdev} /mnt/vzsnap");
    };
    my $err = $@;
    if ($err) {
	eval { run_command ($logfd, "$lvremove -f $bckpar->{snapdev}"); };
	die "mounting snapshot failed - $err";
    }

    my $snapdir = $bckpar->{dir};
    $snapdir =~ s|/?$bckpar->{lvmpath}/?|/mnt/vzsnap/|;

    return $snapdir;
}

#######################################
# VM maintenance and status
#######################################

sub vm_status {
    my ($bckpar,$logfd) = @_;

    my $status;
    if ($bckpar->{vmtype} eq 'openvz') {
	$status = `$vzctl status $bckpar->{vpsid}`;
    } else {
	$status = `qm status $bckpar->{vpsid}`;
    }
    chomp $status;
    $bckpar->{status} = $status;
    $bckpar->{running} = ( $status =~ m/running/ );

    debugmsg ('info', "status = $status", $logfd);

    return $bckpar->{status};
}

sub rsync_vm {
    my ($from,$to,$text,$bckpar,$logfd) = @_;

    debugmsg ('info', "starting $text sync $from to $to", $logfd);
    my $starttime = time();

    my $rsyncopts = "--stats --numeric-ids --bwlimit=${OPT{bwlimit}}";
    if( $OPT{filesys} ){
	$rsyncopts .= " -x";
    }

    my $synccmd = "$rsync $rsyncopts -aH --delete --no-whole-file --inplace $from $to";

    run_command ($logfd, $synccmd);

    my $delay = time () - $starttime;

    debugmsg ('info', "$text sync finished ($delay seconds)", $logfd);
}

sub freeze_vm {
    my ($bckpar, $logfd) = @_;

    if ($bckpar->{stopmode} eq 'stop') {
	debugmsg ('info', "stopping vps", $logfd);
	if ($bckpar->{vmtype} eq 'openvz') {
	    run_command ($logfd, "$vzctl stop $bckpar->{vpsid}");
	} else {
	    my $wait = $OPT{stopwait} * 60;
	    # send shutdown and wait
	    run_command ($logfd, "qm shutdown $bckpar->{vpsid} && qm wait $bckpar->{vpsid} $wait");
	}
    } elsif ($bckpar->{stopmode} eq 'suspend') {
	debugmsg ('info', "suspend vps", $logfd);
	if ($bckpar->{vmtype} eq 'openvz') {
	    run_command ($logfd, "$vzctl chkpnt $bckpar->{vpsid} --suspend");
	} else {
	    run_command ($logfd, "qm suspend $bckpar->{vpsid}");
	}
    } else {
	debugmsg ('warn', "online backup without stop/suspend/snapshot", $logfd);
	debugmsg ('warn', "this can lead to inconsistent data", $logfd);
    }
}

sub dump_checkpoint {
    my ($bckpar, $logfd) = @_;

    safe_mkpath $bckpar->{ctrldir};

    if ($bckpar->{vmtype} eq 'openvz') {
	debugmsg ('info', "dump state of vps to $bckpar->{ctrldir}/state.bin", $logfd);
	run_command ($logfd, "$vzctl chkpnt $bckpar->{vpsid} --dump --dumpfile $bckpar->{ctrldir}/state.bin");
    } else {
	# TODO
	debugmsg ('warn', "Dumping of qm state currently not supported!", $logfd);
    }
}

sub resume_vm {
    my ($bckpar, $logfd) = @_;

    if ($bckpar->{stopmode} eq 'stop') {
	debugmsg ('info', "restarting vps", $logfd);
	if ($bckpar->{vmtype} eq 'openvz') {
	    run_command ($logfd, "$vzctl start $bckpar->{vpsid}");
	} else {
	    run_command ($logfd, "qm start $bckpar->{vpsid}");
	}
    } elsif ($bckpar->{stopmode} eq 'suspend') {
	debugmsg ('info', "resume vps", $logfd);
	if ($bckpar->{vmtype} eq 'openvz') {
	    run_command ($logfd, "$vzctl chkpnt $bckpar->{vpsid} --resume");
	} else {
	    run_command ($logfd, "qm resume $bckpar->{vpsid}");
	}
    } else {
	debugmsg ('warn', "online backup without stop/suspend/snapshot", $logfd);
	debugmsg ('warn', "noting to resume", $logfd);
    }
}

#######################################
# Create and compile archive
#######################################

my @findexcl;

sub find_add_exclude {
    my ($excltype, $value) = @_;

    if (($excltype eq '-regex') || ($excltype eq '-files')) {
	$value = "\.$value";
    }

    if ($excltype eq '-files') {
	push @findexcl, "'('", '-not', '-type', 'd', '-regex' , "'$value'", "')'", '-o';

    } else {
	push @findexcl, "'('", $excltype , "'$value'", '-prune', "')'", '-o';
    }
}

find_add_exclude ('-type', 's'); # skip sockets

sub create_archive {
    my ($src, $archive, $bckpar, $logfd) = @_;

    my $zflag = $OPT{compress} ? 'z' : '';
    my $bwl = $OPT{bwlimit}*1024; # bandwidth limit for cstream

    if ($OPT{stdexcludes}) {
	find_add_exclude ('-files', '/var/log/.+');
	find_add_exclude ('-regex', '/tmp/.+');
	find_add_exclude ('-regex', '/var/tmp/.+');
	find_add_exclude ('-regex', '/var/run/.+pid');
    }

    # backup all types except sockets
    my $findargs = join (' ', @findexcl) . ' -print0';
    if( $OPT{filesys} ){
	$findargs = "-xdev " . $findargs;
    }

    debugmsg ('info', "creating temporary archive '$archive'", $logfd);
    my $cmd = "(cd $src; find . $findargs|tar c${zflag}pf - --totals --sparse --numeric-owner --no-recursion --ignore-failed-read --null -T -| $cstream -t $bwl >$archive)";
    run_command ($logfd, $cmd);
}

sub flush_ctrl {
    my ($dest, $bckpar, $logfd) = @_;

    # check, if we used a temporary directory
    my $is_final = ( $bckpar->{ctrldir} =~ m/^$bckpar->{snapdir}/ );
    # check, if we produced something
    my $ctrlfiles = 0;
    opendir(DIR,$bckpar->{ctrldir});
    $ctrlfiles  = scalar(grep( !/^\.\.?$/,readdir(DIR)));
    closedir(DIR);

    if( $ctrlfiles ){
	if( -e "$bckpar->{ctrldir}/state.bin" ){
	    # this file is heavily inflated, compress before copy
	    unlink "$bckpar->{ctrldir}/state.bin.gz";
	    run_command ($logfd, "$gzip -9 '$bckpar->{ctrldir}/state.bin'");
	}
	if( ! $is_final ){
	    safe_mkpath $dest;
	    run_command ($logfd, "$cpcmd -aR $bckpar->{ctrldir}/* $dest");
	}
    }

    safe_rmtree $bckpar->{ctrldir} unless($is_final);
}

sub copy_conf {
    my ($dest,$bckpar,$logfd) = @_;

    if ($bckpar->{vmtype} eq 'openvz') {
	safe_mkpath "$dest";
	run_command ($logfd, "$cpcmd $bckpar->{srcconf} $dest/vps.conf");
	my $cfgdir = dirname ($bckpar->{srcconf});
	foreach my $s (@script_ext) {
	    my $fn = "$cfgdir/$bckpar->{vpsid}.$s";
	    if (-f $fn) {
		run_command ($logfd, "$cpcmd $fn $dest/vps.$s");
	    }
	}
    } else {
	run_command ($logfd, "$cpcmd $bckpar->{srcconf} $dest/qemu-server.conf");
    }
}

#######################################
# Core state machine
#######################################

# This is only a debugging helper -- not called in the production version
sub dump_bckpar {
    my ($bckpar, $logfd) = @_;

    debugmsg('info', "Dumping current 'bckpar' parameters", $logfd);
    foreach my $k (keys %$bckpar){
	debugmsg('info', "bckpar->$k:\t$bckpar->{$k}", $logfd);
    }
}

sub vm_backup {
    my ($vmlist, $bckpar, $logfd) = @_;

    die "directory '$bckpar->{dir}' does not exist\n" if ! -d $bckpar->{dir};

    my $size = 0;

    eval {
	#
	# Phase 1: determine method
	#
	# whether we use rsync or LVM snapshot
	$bckpar->{use_lvm} = ($bckpar->{stopmode} eq 'snapshot')? 1 : 0;
	$bckpar->{use_lvm} = 1 if( $OPT{lvm} );
	$bckpar->{use_lvm} = determine_lvm($bckpar,$logfd)
	    if ($bckpar->{use_lvm});
	# whether we shall produce a VE state file
	$bckpar->{dump_checkpoint} = 0;
	vm_status($bckpar);
	if ( $bckpar->{running} && $OPT{sane}){
	    $bckpar->{stopmode} = 'suspend' if($bckpar->{use_lvm});
	    $bckpar->{dump_checkpoint} = 1 if($bckpar->{stopmode} eq 'suspend');
	}
	# we will copy from dir - [snapdir] - dumpdir
	if( $OPT{noarch} ){
	    $bckpar->{snapdir} = $bckpar->{dumpdir};
	} else {
	    $bckpar->{snapdir} = $bckpar->{tmpdir};
	    safe_mkpath $bckpar->{snapdir};
	}

	# since we do rsync /my/src/path /my/dst, the base will be /my/dst/path!
	my $subdir = $bckpar->{dir};
	$subdir =~ s+^.*/+/+;
	$subdir =~ s+/*$++;
	$bckpar->{dstdir} = "$bckpar->{snapdir}$subdir";
	# where to put the checkpointing dump files
	if( $bckpar->{dump_checkpoint} ){
	    if(! $bckpar->{use_lvm} ){
		$bckpar->{ctrldir} = "$bckpar->{dstdir}/etc/vzdump";
	    } else {
		# snapshot is not mounted then -- stash it temporarily
		$bckpar->{ctrldir} = "$bckpar->{tmpdir}/ctrl";
	    }
	}
	my $res = run_plugins($plugs,'prepare',$logfd,$bckpar);
	die "Plugin failure in $res->prepare()" if(defined($res));
	#
	# Phase 2: pre-snapshot rsync
	#
	if((! $bckpar->{use_lvm} ) && ($bckpar->{running})){
	    rsync_vm($bckpar->{dir},$bckpar->{snapdir},"first",$bckpar,$logfd);
	}
	$res = run_plugins($plugs,'snapshot',$logfd,$bckpar);
	die "Plugin failure in $res->snapshot()" if(defined($res));
	#
	# Phase 3: freeze machine
	#
	# note: 'snapshot' is a legacy name meaning not to freeze the machine
	if(( $bckpar->{stopmode} ne 'snapshot' ) &&
	   ( $bckpar->{running})){
	    $bckpar->{stoptime} = time();
	    freeze_vm($bckpar,$logfd);
	}
	#
        # Phase 4: snapshot
        #
	if(! $bckpar->{use_lvm} ){
	    rsync_vm($bckpar->{dir},$bckpar->{snapdir},"final",$bckpar,$logfd);
	} else {
	    lvmsnapshot($bckpar,$logfd);
	}
	if ( $bckpar->{dump_checkpoint} ){
	    dump_checkpoint($bckpar,$logfd);
	}
	$res = run_plugins($plugs,'frozen',$logfd,$bckpar);
	#
	# Phase 5: unfreeze machine
	#
	if(( $bckpar->{stopmode} ne 'snapshot' ) &&
	   ( $bckpar->{running})){
	    resume_vm($bckpar,$logfd);
	    my $delay = time () - $bckpar->{stoptime};
	    debugmsg ('info', "vps is online again after $delay seconds", $logfd);
	}
	die "Plugin failure in $res->frozen()" if(defined($res));
	#
	# Phase 6: assemble archive image
	#
	my $dest = "$bckpar->{dstdir}/etc/vzdump";
	if( $bckpar->{use_lvm} ){
	    $bckpar->{lvmsnap} = mount_snapshot($bckpar,$logfd);
	    if( $OPT{noarch} ){
		# files cannot stay here
		rsync_vm($bckpar->{lvmsnap},$bckpar->{snapdir},"archiving",$bckpar,$logfd);
	    } else {
		$dest = "$bckpar->{lvmsnap}/etc/vzdump";
	    }
	}
	flush_ctrl($dest,$bckpar,$logfd) if( exists $bckpar->{ctrldir} );
	copy_conf($dest,$bckpar,$logfd);
	$res = run_plugins($plugs,'assemble',$logfd,$bckpar);
	die "Plugin failure in $res->assemble()" if(defined($res));
	$dest =~ s+/etc/vzdump$++;
	#
	# Phase 7: produce archive and determine size
	#
	if(! $OPT{noarch} ){
	    $bckpar->{tmptar} = $bckpar->{tarfile};
	    $bckpar->{tmptar} =~ s/\.[^\.]+$/\.dat/;
	    unlink $bckpar->{tmptar};
	    create_archive($dest,$bckpar->{tmptar},$bckpar,$logfd);
	    $size = -s $bckpar->{tmptar};

	    my $cs = format_size ($size);
	    debugmsg ('info', "file size $cs", $logfd);

	    rename ($bckpar->{tmptar}, $bckpar->{tarfile}) ||
		die "unable to rename '$bckpar->{tmptar}' to '$bckpar->{tarfile}'\n";

	} else {
	    $size = run_command($logfd,"$ducmd --max-depth 0 $bckpar->{dumpdir}");
	    $size =~ s/\s.*$//g;
	    my $cs = format_size ($size);
	    debugmsg ('info', "directory size $cs", $logfd);
	}
    };

    my $err = $@;

    #
    # Phase 8: clean-up
    #

    lvm_cleanup ($logfd, $bckpar->{snapdev}) if ( exists $bckpar->{snapdev} );
    safe_rmtree $bckpar->{tmpdir};
    rmdir "/mnt/vzsnap" if $OPT{snap};

    unlink $bckpar->{tmptar} if ( exists $bckpar->{tmptar} );

    my $res = run_plugins($plugs,'cleanup',$logfd,$bckpar);

    die $err if $err; # propagate error
    die "Plugin failure in $res->cleanup()" if(defined($res));

    return $size;
}

#######################################
# E-Mail handling
#######################################

sub encode8bit {
    my ($str) = @_;

    $str =~ s/^(.{990})/$1\n/mg; # reduce line length

    return $str;
}

sub escape_html {
    my ($str) = @_;

    $str =~ s/&/&amp;/g;
    $str =~ s/</&lt;/g;
    $str =~ s/>/&gt;/g;

    return $str;
}

# send nicely formated multipart/alternative mail
sub send_mail {
    my ($mailto, $status, $cmdline, $totaltime) = @_;

    my $ecount = 0;
    foreach my $vpsid (keys %$status) {
	$ecount++ if  $status->{$vpsid}->{state} ne 'ok';
	chomp $status->{$vpsid}->{msg} if $status->{$vpsid}->{msg};
	$status->{$vpsid}->{backuptime} = 0 if !$status->{$vpsid}->{backuptime};
    }

    my $stat = $ecount ? 'backup failed' : 'backup successful';

    my $hostname = `hostname`;
    chomp $hostname;

    my $boundary = "----_=_NextPart_001_".int(time).$$;


    my $rcvrarg = '';
    foreach my $r (@$mailto) {
	$rcvrarg .= " '$r'";
    }

    open (MAIL,"|$sendmail -B 8BITMIME $rcvrarg") ||
	die "unable to open $sendmail - $!";

    my $rcvrtxt = join (', ', @$mailto);

    print MAIL "Content-Type: multipart/alternative;\n";
    print MAIL "\tboundary=\"$boundary\"\n";
    print MAIL "FROM: vzdump backup tool <root>\n";
    print MAIL "TO: $rcvrtxt\n";
    print MAIL "SUBJECT: vzdump backup status ($hostname) : $stat\n";
    print MAIL "\n";
    print MAIL "This is a multi-part message in MIME format.\n\n";
    print MAIL "--$boundary\n";

    print MAIL "Content-Type: text/plain;\n";
    print MAIL "\tcharset=\"UTF8\"\n";
    print MAIL "Content-Transfer-Encoding: 8bit\n";
    print MAIL "\n";

    # text part

    my $fill = '  '; # Avoid The Remove Extra Line Breaks Issue (MS Outlook)

    print MAIL sprintf ("${fill}%-10s %-6s %10s %10s  %s\n", qw(VMID STATUS TIME SIZE FILENAME));
    foreach my $vpsid (sort keys %$status) {
	if  ($status->{$vpsid}->{state} eq 'ok') {

	    print MAIL sprintf ("${fill}%-10s %-6s %10s %10s  %s\n", $vpsid,
				$status->{$vpsid}->{state},
				format_time($status->{$vpsid}->{backuptime}),
				format_size ($status->{$vpsid}->{size}),
				$status->{$vpsid}->{tarfile});
	} else {
	    print MAIL sprintf ("${fill}%-10s %-6s %10s %8.2fMB  %s\n", $vpsid,
				$status->{$vpsid}->{state},
				format_time($status->{$vpsid}->{backuptime}),
				0, '-');
	}
    }
    print MAIL "${fill}\n";
    print MAIL "${fill}Detailed backup logs:\n";
    print MAIL "${fill}\n";
    print MAIL "$fill$cmdline\n";
    print MAIL "${fill}\n";

    foreach my $vpsid (sort keys %$status) {
	my $log = $status->{$vpsid}->{tmplog};
	if (!$log) {
	    print MAIL "${fill}$vpsid: no log available\n\n";
	    next;
	}
	open (TMP, "$log");
	while (my $line = <TMP>) { print MAIL encode8bit ("${fill}$vpsid: $line"); }
	close (TMP);
	print MAIL "${fill}\n";
    }

    # end text part
    print MAIL "\n--$boundary\n";

    print MAIL "Content-Type: text/html;\n";
    print MAIL "\tcharset=\"UTF8\"\n";
    print MAIL "Content-Transfer-Encoding: 8bit\n";
    print MAIL "\n";

    # html part

    print MAIL "<html><body>\n";

    print MAIL "<table border=1 cellpadding=3>\n";

    print MAIL "<tr><td>VMID<td>NAME<td>STATUS<td>TIME<td>SIZE<td>FILENAME</tr>\n";

    my $ssize = 0;

    foreach my $vpsid (sort keys %$status) {
	my $name = $status->{$vpsid}->{hostname};
	$name =~ s/\..*$//; # remove domain part

	if  ($status->{$vpsid}->{state} eq 'ok') {

	    $ssize += $status->{$vpsid}->{size};

	    print MAIL sprintf ("<tr><td>%s<td>%s<td>OK<td>%s<td align=right>%s<td>%s</tr>\n",
				$vpsid, $name,
				format_time($status->{$vpsid}->{backuptime}),
				format_size ($status->{$vpsid}->{size}),
				escape_html ($status->{$vpsid}->{tarfile}));
	} else {
	    print MAIL sprintf ("<tr><td>%s<td>%s<td><font color=red>FAILED<td>%s<td colspan=2>%s</tr>\n",

				$vpsid, $name, format_time($status->{$vpsid}->{backuptime}),
				escape_html ($status->{$vpsid}->{msg}));
	}
    }

    print MAIL sprintf ("<tr><td align=left colspan=3>TOTAL<td>%s<td>%s<td></tr>",
 format_time ($totaltime), format_size ($ssize));

    print MAIL "</table><br><br>\n";
    print MAIL "Detailed backup logs:<br>\n";
    print MAIL "<br>\n";
    print MAIL "<pre>\n";
    print MAIL escape_html($cmdline) . "\n";
    print MAIL "\n";

    foreach my $vpsid (sort keys %$status) {
	my $log = $status->{$vpsid}->{tmplog};
	if (!$log) {
	    print MAIL "$vpsid: no log available\n\n";
	    next;
	}
	open (TMP, "$log");
	while (my $line = <TMP>) {
	    if ($line =~ m/^\S+\s\d+\s+\d+:\d+:\d+\s+(ERROR|WARN):/) {
		print MAIL encode8bit ("$vpsid: <font color=red>".
				       escape_html ($line) . "</font>");
	    } else {
		print MAIL encode8bit ("$vpsid: " . escape_html ($line));
	    }
	}
	close (TMP);
	print MAIL "\n";
    }
    print MAIL "</pre>\n";

    print MAIL "</body></html>\n";

    # end html part
    print MAIL "\n--$boundary--\n";
}

#######################################
# Restore
#######################################

sub firstfile {
    my $src = shift;

    my $firstfile = "";
    if( -d $src ){
	opendir(DIR,"$src/etc/vzdump") ||
	    die "unable to open directory '$src/etc/vzdump'\n";
	my @confs = grep( /\.conf$/,readdir(DIR));
	closedir(DIR);
	foreach my $n ('qemu-server', 'vps'){
	    if( scalar(grep( /^$n\.conf$/, @confs)) ){
		$firstfile = "$n.conf";
		last;
	    }
	}
	die "no .conf file in '$src/etc/vzdump'\n" if $firstfile eq "";
    } else {
	open (TMP, "tar tf $src|") ||
	    die "unable to open file '$src'\n";
	$firstfile = <TMP>;
	chomp $firstfile;
	close TMP;
    }
    return $firstfile;

}

sub restore_files {
    my ($src, $dest) = @_;

    my $cmd = "";
    if( -d $src ){
	$src =~ s@/*$@@;
	my $rsyncopts = "--stats --numeric-ids --bwlimit=${OPT{bwlimit}}";
	$cmd = "$rsync $rsyncopts -aH --delete --no-whole-file --inplace ${src}/ $dest";
	debugmsg ('info', "copy files from '${src}'");
    } else {
	$cmd = "zcat -f ${src}| tar xpf - --totals --sparse -C $dest";
	debugmsg ('info', "extracting archive '${src}'");
    }

    run_command (undef, $cmd);
}

sub restore_qemu {
    my ($src, $vpsid) = @_;

    debugmsg ('info', "restore qemu-server image '${OPT{restore}}' using ID $vpsid");

    my $conffile = "/etc/qemu-server/${vpsid}.conf";
    my $private = "/var/lib/vz/images/$vpsid";

    if (-d $private) {
	die "unable to restore VPS '${vpsid}' - directory '$private' already exists\n";
    }

    eval {
	safe_mkpath $private || die "unable to create private dir '$private'";

	restore_files( $src, $private );

	debugmsg ('info', "extracting configuration to '$conffile'");

	my $sfn = "$private/qemu-server.conf";

	run_command (undef, "$cpcmd '$sfn' '$conffile'");
	unlink $sfn;

	debugmsg ('info', "restore successful");

    };

    my $err = $@;

    if ($err) {
	safe_rmtree $private;
	unlink $conffile;
	die $err;
    }
}

sub restore_openvz {
    my ($src, $vpsid, $tmpdir) = @_;

    debugmsg ('info', "restore openvz image '${OPT{restore}}' using ID $vpsid");

    my $vzconf = read_global_vz_config ();
    my $cfgdir = "$vzdir/conf";
    my $conffile = "$cfgdir/${vpsid}.conf";
    my $private = "$vzconf->{privatedir}/${vpsid}";
    my $root = "$vzconf->{rootdir}/${vpsid}";

    if (-d $private) {
	die "unable to restore VPS '${vpsid}' - directory '$private' already exists\n";
    }
    if (-d $root) {
	die "unable to restore VPS '${vpsid}' - directory '$root' already exists\n";
    }

    eval {
	safe_mkpath $private || die "unable to create private dir '$private'";
	safe_mkpath $root || die "unable to create root dir '$root'";

	restore_files( $src, $private );

	debugmsg ('info', "extracting configuration to '$conffile'");

	my $qroot = $root;
	$qroot =~ s|/|\\\/|g;
	$qroot =~ s|/${vpsid}$|/\$VEID|;
	my $qprivate = $private;
	$qprivate =~ s|/|\\\/|g;
	$qprivate =~ s|/${vpsid}$|/\$VEID|;

	my $scmd = "sed -e 's/VE_ROOT=.*/VE_ROOT=\\\"$qroot\\\"/' -e 's/VE_PRIVATE=.*/VE_PRIVATE=\\\"$qprivate\\\"/'  <'$private/etc/vzdump/vps.conf' >'$conffile'";

	run_command (undef, $scmd);

	foreach my $s (@script_ext) {
	    my $tfn = "$cfgdir/${vpsid}.$s";
	    my $sfn = "$private/etc/vzdump/vps.$s";
	    if (-f $sfn) {
		run_command (undef, "$cpcmd '$sfn' '$tfn'");
	    }
	}

	if( -e "$private/etc/vzdump/state.bin.gz" ){
	    # this is a life snapshot with --sane
	    safe_mkpath $tmpdir ||
		die "unable to create temporary dir '$tmpdir'";
	    my $cmd = "$cpcmd '$private/etc/vzdump/state.bin.gz' '$tmpdir/state.bin.gz'";
	    run_command (undef, $cmd);
	    safe_rmtree "$private/etc/vzdump";
	    safe_mkpath "$private/etc/vzdump";
	    $cmd = "$gzip -d '$tmpdir/state.bin.gz' > '$private/etc/vzdump/state.bin'";
	    run_command (undef, $cmd);
	    debugmsg ('info', "Restored checkpointed image; proceed as follows");
	    debugmsg ('info', "vzctl restore ${vpsid} --dumpfile '$private/etc/vzdump/state.bin'");
	    debugmsg ('info', "rm -Rf ${private}/etc/vzdump is safe, if restoration of the VE was successful");
	} else {
	    safe_rmtree "$private/etc/vzdump";
	}
	debugmsg ('info', "restore successful");

    };

    my $err = $@;

    safe_rmtree $tmpdir;

    if ($err) {
	safe_rmtree $private;
	safe_rmtree $root;
	unlink $conffile;
	die $err;
    }
}


#######################################
# argument parsing
#######################################

sub print_usage {
    my $msg = shift;

    print STDERR "ERROR: $msg\n\n" if $msg;

    print STDERR "usage: $0 OPTIONS [--all | VPSID]\n\n";
    print STDERR "\t--exclude VPSID\t\texclude VPSID (assumes --all)\n";
    print STDERR "\t--exclude-path REGEX\texclude certain files/directories\n";     print STDERR "\t--stdexcludes\t\texclude temorary files and logs\n";
    print STDERR "\t--one-filesystem\tdo not recurse directories across file system\n\t\t\t\tborders\n\n";
    print STDERR "\t--compress\t\tcompress dump file (gzip)\n";
    print STDERR "\t--no-archive\t\tjust copy files, do not create an archive\n";
    print STDERR "\t--dumpdir DIR\t\tstore resulting files in DIR\n";
    print STDERR "\t--tmpdir DIR\t\tstore temporary files in DIR\n";
    print STDERR "\t--lvm\t\t\tuse LVM2 snapshot feature, if available\n";
    print STDERR "\t--size MB\t\tLVM snapshot size\n";

    print STDERR "\t--mailto EMAIL\t\tsend notification mail to EMAIL.\n";
    print STDERR "\t--quiet\t\t\tbe quiet.\n\n";
    print STDERR "\t--stop\t\t\tstop/start VPS if running\n";
    print STDERR "\t--suspend\t\tsuspend/resume VPS when running\n";
    print STDERR "\t--snapshot\t\tsnapshot life VM, implies --lvm\n";
    print STDERR "\t--sane\t\t\tuses checkpointing with snapshot to store the\n\t\t\t\tfull state of the machine. It includes the\n\t\t\t\tcheckpointing dump file.\n\n";
    print STDERR "\t--plugin PLUGIN[:args]\tuse PLUGIN for additional state handling and\n\t\t\t\tpass options to the PLUGIN\n\n";

    print STDERR "\t--node CID\t\tonly run on pve cluster node CID\n";
    print STDERR "\t--lockwait MINUTES\tmaximal time to wait for the global lock\n";
    print STDERR "\t--stopwait MINUTES\tmaximal time to wait until a VM is stopped\n";
    print STDERR "\t--bwlimit KBPS\t\tlimit I/O bandwidth; KBytes per second\n\n";

    print STDERR "\t--restore FILENAME\trestore FILENAME\n";

    print STDERR "\n";
}

sub check_module {
    my ($res,$module) = @_;

    # This line already loads the module
    # so be careful
    eval "local \$^W = 0; require $module";
    die "$module cannot be loaded: $@" if($@);
    my $spath = $module;
    $spath =~ s(::)(/)g;
    $spath =~ s/$/.pm/;
    die "$module path unavailabe in %INC!"
        unless(defined(my $fullpath = $INC{$spath}));

    check_perm($fullpath,0644);
    my $moddir = $fullpath;
    $moddir =~ s/$spath$//;
    return if("$res->{plugpath}/" eq "$moddir");

    die "Loaded module $module from invalid path $res->{plugpath}!\n";
}

sub load_plugins {
    my ($res) = @_;

    my @plugs;
    unshift @INC, "$res->{plugpath}";
    foreach my $p (@{$OPT{plugin}}){
	if( ! ($p =~ /^(\w+)\s*(:\s*(.*\S)\s*)?$/)){
	    die "Illegal format of plugin option";
	}
	my $name = $1;
	my @topt = (defined($3))? split(/\s*,\s*/,$3) : ();
	my %popt;
	foreach my $o (@topt){
	    if( ! ($o =~ /^([\w_\-]+)\s*(=\s*(.*\S)\s*)?$/)){
		die "Invalid option for plugin: $name";
	    }
	    my $on = $1;
	    my $oa = $3;
	    $popt{$on} = $oa;
	}
	check_module($res,$name);
	my $vzopt = dclone(\%OPT);
	eval {
	    push @plugs, $name->new($name,\%popt,$vzopt);
	    die "Module does not identitfy!" unless ($plugs[$#plugs]->id() eq "$name");
	};
	my $err = $@;
	if($err){
	    debugmsg('error', "Loading of $name plugin failed!");
	    die $err;
	}
    }
    return \@plugs;
}

sub run_plugins {
    my ($plugs, $meth, $logfd, @args) = @_;

    foreach my $p (@$plugs){
	my $res = 0;
	my $par = dclone(\@args);
	eval {
	    $res = $p->$meth($logfd, @$par);
	};
	my $err = $@;
	if( !defined($res) || ($res == 0) || ($err)){
	    $res = $p->id();
	    $res .= ": $err" if($err);
	    return $res;
	}
    }
    return;
}


#######################################
# Main code
#######################################

# parse parameters first - write errors to STDERR

if (!GetOptions ('all' => \$OPT{all},
		 'exclude=s@' => \$OPT{exclude},
		 'exclude-path=s@' => \$OPT{exclude_path},
		 'stdexcludes' => \$OPT{stdexcludes},
		 'compress' => \$OPT{compress},
		 'restore=s' => \$OPT{restore},
		 'mailto=s@' => \$OPT{mailto},
		 'plugin=s@' => \$OPT{plugin},
		 'quiet' => \$OPT{quiet},
		 'stop' =>\$OPT{stop},
		 'suspend' =>\$OPT{suspend},
		 'snapshot' =>\$OPT{snap},
		 'sane' => \$OPT{sane},
		 'no-archive' => \$OPT{noarch},
		 'one-filesystem' => \$OPT{filesys},
		 'lvm' => \$OPT{lvm},
		 'size=i' => \$OPT{snapsize},
		 'node=i' => \$OPT{node},
		 'bwlimit=i' => \$OPT{bwlimit},
		 'lockwait=i' => \$OPT{lockwait},
		 'stopwait=i' => \$OPT{stopwait},
		 'tmpdir=s' => \$OPT{tmpdir},
		 'dumpdir=s' => \$OPT{dumpdir})) {
    print_usage ();
    exit (-1);
}

$OPT{dumpdir} =~ s|/+$|| if ($OPT{dumpdir});
$OPT{tmpdir} =~ s|/+$|| if ($OPT{tmpdir});


if ($OPT{node}) {
    check_bin (\$pveca, "pveca not installed?");

    my $info = `$pveca -i`;
    chomp $info;
    die "unable to parse pveca info" if $info !~ m/^(\d+)\s+\S+\s+\S+\s+\S+$/;
    my $cid = $1;

    # silent exit if we run on wrong node
    exit (0) if $cid != $OPT{node};
}

$OPT{all} = 1 if $OPT{exclude};

if ($OPT{all} && ($#ARGV >= 0 || $OPT{restore})) {
    print_usage ();
    exit (-1);
}

if (!$OPT{all} && $#ARGV == -1) {
    print_usage ();
    exit (-1);
}

if ($OPT{restore} && $#ARGV != 0) {
    print_usage ();
    exit (-1);
}

if ($OPT{restore} && !(( -f $OPT{restore}) || ( -d $OPT{restore}))) {
    print_usage ("unable to access file '${OPT{restore}}'");
    exit (-1);
}

if (!$OPT{all}) {
    $OPT{vpsids} = [ @ARGV ];

    foreach my $vpsid (@{$OPT{vpsids}}) {
	check_vpsid ($vpsid);
    }
}

if ($OPT{exclude}) {
    foreach my $vpsid (@{$OPT{exclude}}) {
	check_vpsid ($vpsid);
    }
}

if ($OPT{exclude_path}) {
    foreach my $path (@{$OPT{exclude_path}}) {
	find_add_exclude ('-regex', $path);
    }
}

check_bin (\$cpcmd, "unable to find 'cp' command");
check_bin (\$vzctl);
check_bin (\$qmctl);
check_bin (\$sendmail, "sendmail not installed?");
check_bin (\$rsync, "rsync not installed?");
check_bin (\$gzip, "gzip not installed?");

if ($OPT{snap}) {
    check_bin (\$lvcreate, "lvm2 not installed?");
    check_bin (\$lvs, "lvm2 not installed?");
    check_bin (\$lvremove, "lvm2 not installed?");
}

if ($OPT{noarch}) {
    check_bin (\$ducmd, "du not installed?");
} else {
    check_bin (\$cstream, "cstream not installed?");
}

my $def = read_vzdump_defaults();

$plugs = load_plugins($def);

my $tmpdir = "/var/tmp";
$tmpdir = $def->{tmpdir} if defined ($def->{tmpdir});
$tmpdir = $OPT{tmpdir} if defined ($OPT{tmpdir});
$tmpdir .= "/vzdumptmp$$";

# parameters are OK - no start real work and log everything

if ($OPT{restore}) {

    my $vpsid = $OPT{vpsids}[0];

    # try to detect type first
    my $firstfile = firstfile( $OPT{restore} );

    my $vzconffile = "$vzdir/conf/${vpsid}.conf";
    my $qmconffile = "$qmdir/${vpsid}.conf";

    if (-f $vzconffile || -f $qmconffile) {
	die "unable to restore VPS '${vpsid}' - VM already exists\n";
    }

    if ($firstfile eq 'qemu-server.conf') {
	restore_qemu ($OPT{restore}, $vpsid);
    } else {
	restore_openvz ($OPT{restore}, $vpsid, $tmpdir);
    }

    exit 0;
}

$SIG{INT} = $SIG{TERM} = $SIG{QUIT} = $SIG{HUP} = sub {
    die "interrupted by signal\n";
};

debugmsg ('info', "Starting new backup job - $cmdline", undef, 1);

my $maxwait = defined ($OPT{lockwait}) ? $OPT{lockwait} : $def->{lockwait};

getlock($maxwait); # only one process allowed

safe_mkpath $logdir;

eval {

    my $starttime = time();

    my $vmlist = {};

    $OPT{bwlimit} = $def->{bwlimit} if !$OPT{bwlimit};
    $OPT{snapsize} = $def->{size} if !$OPT{snapsize};
    $OPT{stopwait} = $def->{stopwait} if !$OPT{stopwait};

    $stopmode = $def->{mode} if ($def->{mode});
    $stopmode = 'stop' if $OPT{stop};
    $stopmode = 'suspend' if $OPT{suspend};
    $stopmode = 'snapshot' if $OPT{snap};

    # stop is sane by definition!
    $OPT{sane} = 0 if ($stopmode eq 'stop');


    my $dumpdir;

    if ($vzctl) {
	my $vzconf = read_global_vz_config ();
	read_vz_list ($vzconf, $vmlist);
	$dumpdir = $vzconf->{dumpdir};
    }

    if ($qmctl) {
	read_qm_list ($vmlist);
    }

    $dumpdir = $def->{dumpdir} if defined ($def->{dumpdir});
    $dumpdir = $OPT{dumpdir} if defined ($OPT{dumpdir});

    if (!$dumpdir) {
	die "no dumpdir specified - use option '--dumpdir'\n";
    } elsif (! -d $dumpdir) {
	die "dumpdir '$dumpdir' does not exist\n";
    }

    $OPT{vpsids} = [ keys %$vmlist ] if $OPT{all};

    my $status = {};

    my $abort = 0;

    foreach my $vpsid (sort @{$OPT{vpsids}}) {

	next if grep { $_ eq  $vpsid } @{$OPT{exclude}};

	my $res = { size => 0 };
	$res->{hostname} = $vmlist->{$vpsid}->{hostname};

	if ($abort) {
	    $res->{state} = 'err';
	    $res->{msg} = "interrupted by signal";
	    $status->{$vpsid} = $res;
	    next;
	}

	my $logfd;

	my $vmstarttime = time ();

	my $basename = "vzdump-${vpsid}";
	my $logfile  = "$dumpdir/$basename.log";
	my $tmplog   = "$logdir/$vpsid.log";

	my $bckpar = {
	    dumpdir  => $dumpdir,                        # create an image here
	    tmpdir   => $tmpdir,                         # stash files here
	    vmtype   => $vmlist->{$vpsid}->{type},       # VM type (openvz,qemu)
	    dir      => $vmlist->{$vpsid}->{dir},        # VM root directory
	    vpsid    => $vpsid,                          # VM ID
	    stopmode => $stopmode,                       # how to freeze the VM
	    srcconf  => $vmlist->{$vpsid}->{conffile},   # VM configuraion file
	};

	$bckpar->{tarfile} = $res->{tarfile} = "$dumpdir/$basename". ($OPT{compress} ? '.tgz' : '.tar');

	eval {
	    exists ($vmlist->{$vpsid}) ||
		die "unable to find VPS '$vpsid'\n";

	    $logfd = IO::File->new (">$tmplog") ||
		die "unable to create log file '$tmplog'";

	    $res->{tmplog} = $tmplog;

	    unlink $logfile;

	    debugmsg ('info',  "Starting Backup of VM $vpsid ($bckpar->{vmtype})", $logfd, 1);

	    $res->{size} = vm_backup ($vmlist, $bckpar, $logfd);
	};

	my $err = $@;

	my $delay = $res->{backuptime} = time () - $vmstarttime;

	if ($err) {
	    $res->{state} = 'err';
	    $res->{msg} = $err;
	    debugmsg ('err', "Backup of VM $vpsid failed - $err", $logfd, 1);
	} else {
	    $res->{state} = 'ok';
	    debugmsg ('info',
		      sprintf ("Finished Backup of VM $vpsid (%s)",
			       format_time ($delay)),
		      $logfd, 1);
	}

	close ($logfd) if $logfd;

	if ($res->{tmplog}) {
	    system ("$cpcmd $res->{tmplog} $logfile");
	}

	$status->{$vpsid} = $res;

	$abort = 1 if $err =~ m/interrupted by signal/;
    }

    my $totaltime = time() - $starttime;

    if ($OPT{mailto}) {
	eval {
	    send_mail ($OPT{mailto}, $status, $cmdline, $totaltime);
	};

	debugmsg ('err', $@) if $@;
    }
};

my $err = $@;

if ($err) {
    debugmsg ('err', $err, undef, 1);
    exit (-1);
}

exit (0);

__END__

=head1 NAME

vzdump - backup and restore utility for virtual machine

=head1 SYNOPSIS

vzdump OPTIONS [--all | <VMID>]

--exclude VPSID         exclude VPSID (assumes --all)

--exclude-path REGEX    exclude certain files/directories. You
                        can use this option more than once to specify
                        multiple exclude paths

--stdexcludes           exclude temorary files and logs

--one-filesystem        do not recurse directories across file system
                        borders

--compress              compress dump file (gzip)

--no-archive            do not create a tar archive in --dumpdir, but
                        rsync the directory tree to --dumpdir instead.

--dumpdir DIR           store resulting files in DIR

--tmpdir DIR            store temporary files in DIR. --suspend and --stop
                        are using this directory to store a copy of the VM.

--lvm                   use LVM2 snapshots, if available, to minimize
                        downtime. This is required and included , if
                        --snapshot, i.e. a life image of the VM, is
                        selected.

--mailto EMAIL          send notification mail to EMAIL. You can use
                        this option more than once to specify multiple
                        receivers

--stop                  stop/start VPS if running

--suspend               suspend/resume VPS when running

--snapshot              use LVM snapshot when running

--sane                  ensure all information is sane for restart of the
                        VPS. Currently this is done by a stop/start
                        sequence, which can be shorter than --stop, e.g.
                        using an LVM snapshot.

--size MB               LVM snapshot size (default 1024)

--plugin PLUGIN[:args]  load the PLUGIN and pass args to it. Arguments
                        are delivered as a colon separated list of
                        'option' or 'option=value' entries. For
                        documentation of plugins, refer to the plugins.

--bwlimit KBPS          limit I/O bandwidth; KBytes per second

--lockwait MINUTES      maximal time to wait for the global
                        lock. vzdump uses a global lock file to make
                        sure that only one instance is running
                        (running sereral instance puts too much load
                        on a server). Default is 180 (3 hours).

--stopwait MINUTES      maximal time to wait until a VM is stopped.

--restore FILENAME      restore FILENAME; if FILENAME is a directory
                        it is treated as the target of a --no-archive
                        dump

=head1 DESCRIPTION

vzdump is an utility to make consistent snapshots of running VMs
(openvz and qemu-server images). It basically creates a tar archive of
the VM private area, which also includes the VM configuration files.

There are several ways to provide consistency:

- stop the VM during backup (very long downtime)

- use rsync and suspend/resume (minimal downtime).

- use LVM2 (no downtime, but needs LVM2 and free space on the corresponding volume group to create the LVM snapshot)

=head1 CONFIGURATION

Global configuration is stored in /etc/vzdump.conf.

 tmpdir: DIR
 dumpdir: DIR
 mode: snapshot|suspend|stop
 bwlimit: KBPS
 lockwait: MINUTES
 stopwait: MINUTES
 size: MB

=head1 FILES

vzdump skips the following files wit option --stdexcludes

 /var/log/.+
 /tmp/.+
 /var/tmp/.+
 /var/run/.+pid

You can manually specify exclude paths, for example:

> vzdump --exclude-path '/tmp/.+' --exclude-path '/var/tmp/.+' 777

(only excludes tmp directories)

Configuration files are also stored inside the backup archive (/etc/vzdump), and will be correctly restored with --restore

=head1 EXAMPLES

Simply dump VM 777 - no snapshot, just archive the VM private area and configuration files to the default dump directory (usually /vz/dump/).

> vzdump 777

Use rsync and suspend/resume to create an snapshot (minimal downtime).

> vzdump --suspend 777

Backup all VMs and send notification mails to root.

> vzdump --suspend --all --mailto root

Use LVM2 to create snapshots (no downtime).

> vzdump --dumpdir /mnt/backup --snapshot 777

Restore above backup to VM 600

> vzdump --restore /mnt/backup/vzdump-777.tar 600

Backup all VMSs excluding VM 101 and 102

> vzdump --suspend --exclude 101 --exclude 102

=head1 AUTHOR

Dietmar Maurer <dietmar@proxmox.com>

Many thanks to Proxmox Server Solutions (www.proxmox.com) for sponsoring
this work.

Contributors: Lars Hanke <lars@lhanke.de>

=head1 COPYRIGHT AND DISCLAIMER

Copyright (C) 2007-2008 Proxmox Server Solutions GmbH

Copyright: vzdump is under GNU GPL, the GNU General Public License.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 dated June, 1991.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the
Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
MA 02110-1301, USA.

